主程序：/home/joe/sdn/graph/dijkstra_heap/main.c
读取拓扑：topoNo1deg3.txt 从0到6743，26501条边。
输出结果：Num_of_entry.txt
总跳数		频次
	1		53002
	2		13389038
	3		171289397
	4		150455555
	5		21387207
	6		749243
	7		6253
	8		2
the total time is 357329697

增加跳数		频次
	0		105824611
	1		145796266
	2		89810896
	3		14706962
	4		1147538
	5		42858
	6		564
	7		2
	8		0
	9		0
	10		0
	11		0
	12		0
	13		0
	14		0
	15		357329697
There are 62789 times cant get the dest.
where the total time is 357329697


增加%		频次
	100		105824611
	120		3272
	125		1701254
	133		59387402
	140		12
	150		84389038
	166		10815096
	175		1174
	200		74194836
	233		4043
	250		7832578
	300		5741897
	350		460
	400		6431910
	500		959150
	600		42398
	700		564
	800		2
where the total time is 357329697


实验任务2：随机转发，需要新占用邻居交换机的流表空间，每单个数据包随机转发，每一条扩散的流均经过所有的邻居。统计需要增多多少个流表项。
/home/joe/sdn/graph/dij_entry/main.c
用链表记录源到各个目的地的路径：

| 1 3 4 2
1 ○ | 。。。。
	| 。。。。


用链表记录邻居到各个目的地的路径：

	| 9 6 8 7 4 2
9△	| 。。。。
	| 。。。。
gcc main.c –o main –O1//开大O1优化。
从原点到2，经历4个点；从邻居9到2，经历6个点，且不经过源点。一共经历6个点
统计0. 最少需要建立的流表项数目。√
总entry数量		频次
	1		6744
	2		53002
	3		9551246
	4		31038106
	5		4795828
	6		36604
	7		6
	999		45481536
总频次 = 45481536
统计1.之前没有建立过路径，需要统计到目的地所有的。All_hop √
	从邻居算dijkstra，到每一个目的地，有多少种路。得到一个neighbor_hop.
将每一个neibor_hop加入到all_hop里，只加不重复的，array代表同一个目的地的所有hop。不加入源点（起点），因为扩散后不能往回。
将总数统计到sum_entry[]

	
统计2. 之前曾经建立过路径，则只需要统计新添加的流表项数目。
	原始路径存到src_route内。先将src_route加入到all2_hop里，清空all2_hop的sum
再加入neighbor_hop. 不加入源点（起点），因为扩散后不能往回。
将总数统计到sum2_entry[]


2.2单节点最大可扩散的端口数量
 
6744个节点，流表数量使用，蓝色三角代表一条已经被路由好的流中某一个节点溢出，在此节点随机扩散后新增加的流表项数目。
红色源点表示此流未被处理过，在路径中出现流表溢出的交换机，在此交换机节点随机扩散这条新流到达目的地所需要的总流表项。
